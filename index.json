[{"content":"一、字符串常用方法 1、索引-str[0] #从0开始 msg=\u0026#34;bobby\u0026#34; #b print msg[0] 2、切片-str[:::] # 索引切片 msg = \u0026#39;hello nick\u0026#39; # 0123456789 # 索引序号 print(f\u0026#39;切片3-最后: {msg[3:]}\u0026#39;) print(f\u0026#39;切片3-8: {msg[3:8]}\u0026#39;) print(f\u0026#39;切片3-8，步长为2: {msg[3:8:2]}\u0026#39;) print(f\u0026#39;切片3-最后，步长为2: {msg[3::2]}\u0026#39;) # 了解，步长为正从左到右；步长为负从右到左 print(\u0026#39;\\n**了解知识点**\u0026#39;) print(f\u0026#39;切片所有: {msg[:]}\u0026#39;) print(f\u0026#39;反转所有: {msg[::-1]}\u0026#39;) print(f\u0026#39;切片-5--2: {msg[-5:-2:1]}\u0026#39;) print(f\u0026#39;切片-2--5: {msg[-2:-5:-1]}\u0026#39;) 3、长度-len(str) msg=\u0026#34;bobby\u0026#34; #5 print len(msg) 4、成员运算in和not in msg=\u0026#34;bobby\u0026#34; #True print \u0026#34;b\u0026#34; in msg #False print \u0026#34;k\u0026#34; in msg 5、移除前后空白或字符-str.strip(\u0026ldquo;值\u0026rdquo;) #去除字符串开头和结尾处指定的字符(默认为空格或换行符)或字符序列，不会去除字符串中间对应的字符。 msg=\u0026#34; bobby \u0026#34; #bobby print msg.strip() #bobby msg=\u0026#34;*#$bobby+\u0026#34; print msg.strip(\u0026#34;*#$+\u0026#34;) 6、切割左到右，与右到左切割-str.split(\u0026ldquo;值\u0026rdquo;)和str.rsplit(\u0026ldquo;值\u0026rdquo;) #方法通过指定分隔符对字符串进行分割并返回一个列表，默认分隔符为空字符，包括空格，换行（\\n）,制表符（\\t）等 msg = \u0026#34; bobby jkkjjkkj\\nllll\\t222\u0026#34; # [\u0026#39;bobby\u0026#39;, \u0026#39;jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;,‘222’] print msg.split() msg = \u0026#34; bobby:jkkjjkkj:llll\u0026#34; # [\u0026#39;bobby\u0026#39;, \u0026#39;jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;] print msg.split(\u0026#34;:\u0026#34;) #左右切割用法一致，在不控制切割第几个字符的情况下返回值都是一样的，控制切割后结果才会不一样 msg = \u0026#34; bobby:jkkjjkkj:llll\u0026#34; # [\u0026#39; bobby\u0026#39;, \u0026#39;jkkjjkkj:llll\u0026#39;] # [\u0026#39; bobby:jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;] print msg.split(\u0026#34;:\u0026#34;,1) print msg.rsplit(\u0026#34;:\u0026#34;,1) 7、循环-for #for 循环取值 msg = \u0026#34; bobby jkkjjkkj\\nllll\\t222\u0026#34; for i in msg: print i 二、字符串需要掌握内置方法 1、去除字符串左右两边空格或指定字符-str.lstrip(\u0026ldquo;值\u0026rdquo;)和str.rstrip(\u0026ldquo;值\u0026rdquo;) #lstrip()用于去除字符串左边的空格或指定字符 #rstrip()用于去除字符串右边的空格或指定字符。 #lstrip和rstrip去除字符串原理与strip相同，只不过lstrip只从左侧进行匹配去除，rstrip只从右侧进行匹配去除 msg = \u0026#34;***bobby\u0026amp;\u0026amp;\u0026amp;\u0026#34; #bobby\u0026amp;\u0026amp;\u0026amp; #***bobby print msg.lstrip(\u0026#34;*\u0026#34;) print msg.rstrip(\u0026#34;\u0026amp;\u0026amp;\u0026#34;) 2、字符串转换大小写\u0026ndash;str.upper()和str.lower() #lower()小写，upper()大写 msg = \u0026#34;***bobby\u0026amp;\u0026amp;\u0026amp;\u0026#34; #***bobby\u0026amp;\u0026amp;\u0026amp; #***BOBBY\u0026amp;\u0026amp;\u0026amp; print msg.lower() print msg.upper() 3、对比字符串开头结尾值-startswith(\u0026ldquo;值\u0026rdquo;)和endswith(\u0026ldquo;值\u0026rdquo;) msg = \u0026#34;bobbysheng\u0026#34; #True #True print msg.startswith(\u0026#34;bobby\u0026#34;) print msg.endswith(\u0026#34;sheng\u0026#34;) 4、连接列表中的字符串-\u0026quot; \u0026ldquo;.join(list) #把列表值全部拆出来，填充上指定的值。与split切割方方法完全相反 #join将 容器对象 拆分并以指定的字符将列表内的元素(element)连接起来，返回字符串（注：容器对象内的元素须为字符类型） li = [\u0026#39;my\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;is\u0026#39;,\u0026#39;bob\u0026#39;] s = [\u0026#39;my\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;bob\u0026#39;] # my name is bob # my_name_is_bob print \u0026#39; \u0026#39;.join(li) print \u0026#39;_\u0026#39;.join(li) #可以通过split方法把join填充的值全部复原为一个列表 li_join=\u0026#34;my_name_is_bob\u0026#34; # [\u0026#39;my\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;bob\u0026#39;] print li_join.split(\u0026#34;_\u0026#34;) 5、替换字符串-str.replace(old, new[, max]) #把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 str = \u0026#34;this is string example....wow!!! this is really string\u0026#34; #thwas was string example....wow!!! thwas was really string #thwas was string example....wow!!! thwas is really string print str.replace(\u0026#34;is\u0026#34;, \u0026#34;was\u0026#34;) print str.replace(\u0026#34;is\u0026#34;, \u0026#34;was\u0026#34;, 3) 6、方法检测字符串是否只由数字组成-str.isdigit() #如果字符串包含的是数字类型则返回 True 否则返回 False。 str = \u0026#34;111\u0026#34; str_false = \u0026#34;111.2\u0026#34; #True print str.isdigit() #False print str_false.isdigit() 7、字符串find()、rfind()、index()、rindex()、count() # find()、rfind()、index()、rindex()、count() msg = \u0026#39;my name is tank, tank shi sb, hha\u0026#39; #11 #-1 #17 #11 #17 #2 print msg.find(\u0026#39;tank\u0026#39;) # 找不到返回-1 print msg.find(\u0026#39;tank\u0026#39;,0,3) # 找不到返回-1 print msg.rfind(\u0026#39;tank\u0026#39;) # 找不到返回-1 print msg.index(\u0026#39;tank\u0026#39;) # 找不到报错 print msg.rindex(\u0026#39;tank\u0026#39;) # 找不到报错 print msg.count(\u0026#39;tank\u0026#39;) 8、字符串添加内容center()、ljust()、rjust()、zfill() center,ljust,rjust,zfillcenter：在center内容中间添加内容 print(\u0026#39;egon\u0026#39;.center(50,\u0026#39;*\u0026#39;)) ***********************egon*********************** ljust：在ljust内容左边添加内容 print(\u0026#39;egon\u0026#39;.ljust(50,\u0026#39;*\u0026#39;)) egon********************************************** rjust：在ljust内容右边添加内容 print(\u0026#39;egon\u0026#39;.rjust(50,\u0026#39;*\u0026#39;)) **********************************************egon zfill：在zfill内容中加到指定个数 print(\u0026#39;egon\u0026#39;.zfill(10)) 000000egon 9、字符串设置制表符代表的空格数str.expandtabs() #expandtabs()方法返回一个字符串的副本，其中tab字符。使用空格扩展’\\t‘，可选地使用给定的制表符大小 - tabize(默认值为8)。 expandtabs 设置制表符代表的空格数 msg=\u0026#39;hello\\tworld\u0026#39; print(msg.expandtabs(2)) # 设置制表符代表的空格数为2 hello world 10、字符串captalize()、swapcase()、title() captalize：一段字符串的首个字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.capitalize()) Hello world egon swapcase：一段字符串的首个字母小写，其余大写 print(\u0026#34;Hello WorLd EGon\u0026#34;.swapcase()) hELLO wORlD egON title：每个单词的首字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.title()) Hello World Egon 11、字符串captalize()、swapcase()、title() captalize：一段字符串的首个字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.capitalize()) Hello world egon swapcase：一段字符串的首个字母小写，其余大写 print(\u0026#34;Hello WorLd EGon\u0026#34;.swapcase()) hELLO wORlD egON title：每个单词的首字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.title()) Hello World Egon 12、is系列，判断字符串是否属于此格式 1、.isdigit()：判断是否全部都是纯数字类型 print(\u0026#39;123\u0026#39;.isdigit()) True 2、.islower()：判断是否全部都是小写字母 print(\u0026#39;abc\u0026#39;.islower()) True 3、.isupper()：判断是否全部都是大写字母 print(\u0026#39;ABC\u0026#39;.isupper()) True 4、.istitle()：判断是否是单词首个字母大写 print(\u0026#39;Hello World\u0026#39;.istitle()) True/5、.isalnum()：判断是否由数字或字母组成 print(\u0026#39;123123aadsf\u0026#39;.isalnum()) # 字符串由字母或数字组成结果为True True 6、.isalpha()：判断是否全部由字母构成 print(\u0026#39;ad\u0026#39;.isalpha()) # 字符串由由字母组成结果为True True 7、.isspace()：判断是否全部由空格构成 print(\u0026#39; \u0026#39;.isspace()) # 字符串由空格组成结果为True True 8、.isidentifier()：判断是否可以定义为变量名 print(\u0026#39;print\u0026#39;.isidentifier()) print(\u0026#39;age_of_egon\u0026#39;.isidentifier()) print(\u0026#39;1age_of_egon\u0026#39;.isidentifier()) True True False # 变量名不能以数字开头 13、数字系列的识别 先定义表示同一个数字的4个不同方法： num1=b\u0026#39;4\u0026#39; #bytes num2=u\u0026#39;4\u0026#39; #unicode,python3中无需加u就是unicode num3=\u0026#39;四\u0026#39; #中文数字 num4=\u0026#39;Ⅳ\u0026#39; #罗马数字 isdigit只能识别：num1、num2 print(num1.isdigit()) # True print(num2.isdigit()) # True print(num3.isdigit()) # False print(num4.isdigit()) # False True True False False isnumberic可以识别：num2、num3、num4 print(num2.isnumeric()) # True print(num3.isnumeric()) # True print(num4.isnumeric()) # True True True True isdecimal只能识别：num2 print(num2.isdecimal()) # True print(num3.isdecimal()) # False print(num4.isdecimal()) # False True False False ","permalink":"https://bobby-sheng.github.io/posts/tech/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/","summary":"一、字符串常用方法 1、索引-str[0] #从0开始 msg=\u0026#34;bobby\u0026#34; #b print msg[0] 2、切片-str[:::] # 索引切片 msg = \u0026#39;hello nick\u0026#39; # 0123456789 # 索引序号 print(f\u0026#39;","title":"Python字符串详解"},{"content":"笔记背景 好记性不如烂笔头，在需要的时经常断片忘记基础方法，写这笔记目的一是加深印象，二是实在记不得也不需要去外网寻找找影响效率。\n一、列表常用方法 1、索引取值-list[index] 按索引取值（正向取值+反向取值），即可存也可以取\n# list之索引取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list[0] = \u0026#39;nick handsom\u0026#39; 存入到第一个索引位置中 # name_list[1000] = \u0026#39;tank sb\u0026#39; # 报错 #\u0026#34;nick handsom\u0026#34; pring name_list[0] 2、切片 切片操作基本表达式：[start_index：stop_index：step] start 值\n2.1、获取单个元素 list =[\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] #red print(list[0]) # black print(list[-1]) 2.2、获取列表对象 list = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 从左往右获取索引,[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] \u0026#39;\u0026#39;\u0026#39; print(list[:]) print(list[::]) print(list[::1]) \u0026#39;\u0026#39;\u0026#39; 从右往左获取索引（反向索引）,[\u0026#39;black\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;] \u0026#39;\u0026#39;\u0026#39; print(list[::-1]) 2.3、获取列表部分的值 （1）正向索引\nlist = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 反向索引：step为负数 \u0026#39;\u0026#39;\u0026#39; # 正向索引：start_index为0到end_index为6 print(list[0:6]) # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # start_index没有填写，默认从第一个开始,一直取到end_index=6 print(list[:6]) # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # step没有填写，默认是1，start_index为0,一直取到end_index=2 print(list[0:2]) #[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;] # step没有填写，默认是1，start_index为1,一直取到end_index=4 print(list[1:4]) # [\u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;] # start_index为1,一直取到end_index=5，step是2 print(list[1:5:2]) # [\u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;] （2）反向索引\nlist = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 反向索引：step为负数 \u0026#39;\u0026#39;\u0026#39; print(\u0026#34;反向索引=============\u0026#34;) # step=1，反向索引，从start_index=-6开始，一直取到end_index=0为止。 print(list[-6::]) #[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # step=-1，反向索引，从start_index=3开始，一直取到end_index=0为止。 print(list[3:0:-1]) #[\u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] # step=-2，反向索引，从start_index=6开始，一直取到end_index=0为止。 print(list[6::-2]) #[\u0026#39;black\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] # step=-3，反向索引，从start_index=5开始，一直取到end_index=2为止。 print(list[5:2:-3]) #[\u0026#39;black\u0026#39;] # step=-1，反向索引，从start_index=-3开始，一直取到end_index=-5为止。 print(list[-3:-5:-1]) #[\u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;] # start_index \u0026gt; end_index时，取出的结果为空 print(list[4:2]) #[] print(list[-5:-3:-1]) # [] 2.4、列表多层切片 \u0026#39;\u0026#39;\u0026#39;多层切片\u0026#39;\u0026#39;\u0026#39; list = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] # 链式列表切片 print(list[:6][2:5][-1:]) \u0026#39;\u0026#39;\u0026#39;上边的链式列表与下边的步骤是相等的\u0026#39;\u0026#39;\u0026#39; list2 = list[:6] # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] print(list2) list3 = list2[2:5] # [\u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;] print(list3) list4 = list3[-1:] # [\u0026#39;white\u0026#39;] print(list4) 3、长度-len(list) # list之长度 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 4 print(len(name_list)) # list之多维列表长度 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;]] # 3 print(len(name_list[4])) 4、成员运算in和not in # list之成员运算in和not in name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] #False print(\u0026#39;tank sb\u0026#39; in name_list) #Ture print(\u0026#39;nick handsome\u0026#39; not in name_list) 5、追加值-append（值） # list之追加值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.append(\u0026#39;tank sb\u0026#39;) #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#39;tank sb\u0026#39;] print name_list 6、删除值-del list[index] # list之删除值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] del name_list[2] #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#39;tank sb\u0026#39;] print name_list 7、列表循环取值 # list之列表循环取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] 第一种：for name in name_list: print(name) 第二种：li=[i for i in name_list] 二、列表内置方法 1、列表插入-insert(index) #使用方法insert(index,list) #注意：如果索引超出范围,则如果索引为正,则该项目将追加到末尾；如果索引为负,则将其追加到开头，没有例外. \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.insert(5, \u0026#39;item\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;item\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.insert(-3, \u0026#39;item\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;item\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 2、列表删除-pop(index) #使用方法 list.pop(),index为空默认删除最后一个值[-1] #注意：此方法会返回删除数据的值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.pop(1) #[\u0026#39;nick\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print(name_list) 3、列表删除-remove(值) # 使用方法list.remove(值),会删除匹配到的第一个值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.remove(\u0026#39;jason\u0026#39;) #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print name_list 4、列表重复值统计-count(值) # 使用方法list.count(值),会统计列表中值的个数 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 2 print name_list.count(\u0026#39;jason\u0026#39;) 5、列表值的索引位置-index(值) # 使用方法list.index(值),会查找出列表中匹配到的第一个值的位置 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 1 print name_list.index(\u0026#39;jason\u0026#39;) 6、列表清除内容-clear() # 使用方法list.clear(),清除列表内容 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.clear() # [] print name_list 7、列表复制-copy() # 使用方法list.copy(),清除列表内容 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list_copy=name_list.copy() # [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print name_list_copy 8、列表合并-extend(list2) # 使用方法list1.extend(list2),合并两个值列表为一个 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list_copy=[\u0026#34;nick_aaaa\u0026#34;] name_list.extend(name_list_copy) # [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#34;nick_aaaa\u0026#34;] print name_list 9、列表反转-reverse() # 使用方法list.reverse(),列表反转 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.reverse() # [\u0026#39;sean\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;jason\u0026#39;, \u0026#39;nick\u0026#39;] print name_list 10、列表排序-sort() # 使用方法list.sort(),使用sort列表的元素必须是同类型的 #列表内的元素，按照由小到大顺序进行排序。 list_val = [12,32,9,89,10,3,100,45,56] list_val.sort() # [3, 9, 10, 12, 32, 45, 56, 89, 100] print(list_val) #列表内的元素，按照由大到小顺序排序。 list_val = [12,32,9,89,10,3,100,45,56] list_val.sort(reverse=Ture) # [100, 89, 56, 45, 32, 12, 10, 9, 3] print(list_val) ","permalink":"https://bobby-sheng.github.io/posts/tech/python%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","summary":"笔记背景 好记性不如烂笔头，在需要的时经常断片忘记基础方法，写这笔记目的一是加深印象，二是实在记不得也不需要去外网寻找找影响效率。 一、列表常用","title":"Python列表方法详解"},{"content":"1、普通计算方法 计算公式：TPS= 总请求数 / 总时间 按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为4.13万（1次浏览都至少对应1个请求） 总请求数 = 4.13 万请求数 = 41300 请求数 总时间：由于不知道每个请求的具体时间，我们按照普通方法，我们可以按照一周的时间进行计算，总时间 = 1天 = 1 * 24 小时 = 24 * 3600 秒 套入公式可得：TPS = 41300请求数/24*3600秒 = 0.48请求数/秒 结论：按照普通计算方法，我们在测试环境对相同的系统进行性能测试时，每秒能够发送0.48请求就可以满足线上的需要 2、二八原则计算方法 二八原则就是指80%的请求在20%的时间内完成 计算公式 ： TPS = 总请求数 80% / (总时间20%) **按照公式进行计算：TPS = 41300 * 0.8请求数 / 24*3600*0.2秒 = 1.91 请求数/秒 **结论：**按照二八原则计算，在测试环境我们的TPS只要能达到1.91请求数每秒就能满足线上需要。二八原则的估算结果会比平均值的计算方法更能满足用户需求。 3、照业务数据进行计算 计算模拟用户正常业务操作（稳定性测试）的并发量： 根据这些数据统计图，可以得出结论： 大部分订单在8点-24点之间，因此系统的有效工作时长为16个小时 从订单数量统计，8-24点之间的订单占一天总订单的98%左右（40474个） 结合二八原则计算公式 ： TPS = 总请求数 80% / (总时间20%) 需要在测试环境模拟用户正常业务操作（稳定性测试）的并发量为：TPS = 40474 * 0.8请求数 / 16*3600*0.2秒 = 2.81 请求数/秒 计算模拟用户峰值业务操作（压力测试）的并发量： 根据这些数据统计图，可以得出结论： 订单最高峰在在21点-22点之间，一小时的订单总数大约为8853个 计算压力测试的并发数：TPS = 峰值请求数/峰值时间 * 系数 需要在测试环境模拟用户峰值业务操作（压力测试）的并发量为： TPS = 8853 请求数 / 3600秒 * 3（系数） = 7.38 请求数/秒 ","permalink":"https://bobby-sheng.github.io/posts/tech/%E5%8E%8B%E6%B5%8B%E9%9C%80%E6%B1%82%E5%AE%9A%E5%88%B6%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","summary":"1、普通计算方法 计算公式：TPS= 总请求数 / 总时间 按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为","title":"压测需求定制计算方法"},{"content":"一、文档读写实用方法 1、readline()函数\n解释：此函数读取文件默认打印第一行，后面可以接参数打印字符个数\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readline() print rows 2、readlines()函数\nfile.readline()[index]\n解释：此函数把文件作列表全部读取出来，可通过for循环获取每一行的值\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): print i 2、read()函数\n解释：此函数把文件样式原封不动的打印出来\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.read() print rows 二、打开文件模式解释 ### 常用模式打开文件 # 1.r模式 # 2.w模式:写入的文件不存在会自动创建，每一次写入都会覆盖前面的内容 # 3.a模式：与w模式一样，但是内容会追加 # 4.b模式：字节读取+字节写入 ### 其他模式模式 # 1.r+--打开文件用于读写，文件指针会放在文件开头 # 2.rb+--二进制打开文件用于读写，文件指针会放在文件开头 # 3.w+--打开文件用于读写，并且从头开始编辑，会覆盖原内容 # 4.wb+--二进制打开文件用于读写，并且从头开始编辑，会覆盖原内容 # 5.ab--二进制打开用于追加，指针放末尾，只能写 # 6.ab+--二进制打开文件用于追加，指针放末尾 # 7.a+--打开文件读写，指针放末尾，文件存在追加模式，不存在新建 三、文件读写案例 案例一\n解释：打开文件，获取文件所在行之后，赋值。在打开文件写入变量中的值\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): if content[3] in line: a = i for k in range(a, a+60): if \u0026#34;expect_return = \u0026#34; in rows[k]: rows[k] = \u0026#34; expect_return =\u0026#34; + content[2] break log.info(\u0026#34;写入\u0026#34;) with open(p, \u0026#39;w+\u0026#39;) as w: w.writelines(rows) 案例二\n解释：一次性打开多个文件，实现文件的快速拷贝。\nwith open(\u0026#39;32.txt\u0026#39;, \u0026#39;rb\u0026#39;) as fr, \\ open(\u0026#39;35r.txt\u0026#39;, \u0026#39;wb\u0026#39;) as fw: f.write(f.read()) 案例三\nimport os with open(\u0026#39;37r.txt\u0026#39;) as fr, \\ open(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: data = fr.read() # 全部读入内存,如果文件很大,会很卡 data = data.replace(\u0026#39;tank\u0026#39;, \u0026#39;tankSB\u0026#39;) # 在内存中完成修改 fw.write(data) # 新文件一次性写入原文件内容 # 删除原文件 os.remove(\u0026#39;37r.txt\u0026#39;) # 重命名新文件名为原文件名 os.rename(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;37r.txt\u0026#39;) print(\u0026#39;done...\u0026#39;) 案例四\nimport os with open(\u0026#39;37r.txt\u0026#39;) as fr,\\ open(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: # 循环读取文件内容，逐行修改 for line in fr: line = line.replace(\u0026#39;jason\u0026#39;, \u0026#39;jasonSB\u0026#39;) # 新文件写入原文件修改后内容 fw.write(line) os.remove(\u0026#39;37r.txt\u0026#39;) os.rename(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;37r.txt\u0026#39;) print(\u0026#39;done...\u0026#39;) 四、总结 修改文件内容的思路为：以读的方式打开原文件，以写的方式打开一个新的文件，把原文件的内容进行修改，然后写入新文件，之后利用os模块的方法，把原文件删除，重命名新文件为原文件名，达到以假乱真的目的\n","permalink":"https://bobby-sheng.github.io/posts/tech/python%E6%96%87%E6%A1%A3%E8%AF%BB%E5%86%99%E6%96%B9%E6%B3%95/","summary":"一、文档读写实用方法 1、readline()函数 解释：此函数读取文件默认打印第一行，后面可以接参数打印字符个数 with open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readline() print rows 2、rea","title":"python文档读写方法"},{"content":"docker主要分为镜像、容器。个人理解镜像是一个封装好的仓库，容器就是把这个仓库拿过来，里面的东西原封不动，可以随意操作而不会影响镜像内容，一个镜像可以创建多个容器。比较方便\n一、docker基础命令 1.启动docker\nsystemctl start docker 2.关闭docker\nsystemctl stop docker 3.重启docker\nsystemctl restart docker 4.docker设置随服务启动而自启动\nsystemctl enable docker 5.查看docker 运行状态\nsystemctl status docker 6.查看docker 版本号信息\ndocker version docker info 7.docker 帮助命令\ndocker --help docker pull --help 二、docker镜像命令 1.查看自己服务器中docker 镜像列表\ndocker images 2.搜索镜像\ndocker search 镜像名 3.拉取镜像\ndocker pull 镜像名 docker pull 镜像名:tag 4.运行镜像\ndocker run 镜像名 docker run 镜像名:Tag docker pull tomcat docker run tomcat 5.删除镜像 \u0026mdash;\u0026mdash;当前镜像没有被任何容器使用才可以删除\n#删除一个 docker rmi -f 镜像名/镜像ID #删除多个 其镜像ID或镜像用用空格隔开即可  docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID #删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID docker rmi -f $(docker images -aq) 6.强制删除镜像\ndocker image rm 镜像名称/镜像ID 7.保存镜像 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像\ndocker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字 docker save tomcat -o /myimg.tar 8.加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像\ndocker load -i 镜像保存文件位置 9.镜像标签 有的时候呢，我们需要对一个镜像进行分类或者版本迭代操作，比如我们一个微服务已经打为docker镜像，但是想根据环境进行区分为develop环境与alpha环境，这个时候呢，我们就可以使用Tag，来进对镜像做一个标签添加，从而行进区分；版本迭代逻辑也是一样，根据不同的tag进行区分\napp:1.0.0 基础镜像 # 分离为开发环境 app:develop-1.0.0 # 分离为alpha环境 app:alpha-1.0.0 docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] docker tag 源镜像名:TAG 想要生成新的镜像名:新的TAG # 如果省略TAG 则会为镜像默认打上latest TAG docker tag aaa bbb # 上方操作等于 docker tag aaa:latest bbb:test # 我们根据镜像 quay.io/minio/minio 添加一个新的镜像 名为 aaa 标签Tag设置为1.2.3 docker tag quay.io/minio/minio:1.2.3 aaa:1.2.3 # 我们根据镜像 app-user:1.0.0 添加一个新的镜像 名为 app-user 标签Tag设置为alpha-1.0.0 docker tag app-user:1.0.0 app-user:alpha-1.0.0 三、docker容器命令 1.查看正在运行容器列表\ndocker ps 2.查看所有容器 \u0026mdash;\u0026ndash;包含正在运行 和已停止的\ndocker ps -a 容器怎么来呢 可以通过run 镜像 来构建 自己的容器实例 3.运行一个容器\n# -it 表示 与容器进行交互式启动 -d 表示可后台运行容器 （守护式运行） --name 给要运行的容器 起的名字 /bin/bash 交互路径 docker run -it -d --name 要取的别名 镜像名:Tag /bin/bash #1. 拉取redis 镜像 docker pull redis:5.0.5 #2.命令启动 docker run -it -d --name redis001 redis:5.0.5 /bin/bash #3.查看已运行容器 docker ps # netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息 netstat -untlp 4.删除容器\n删除一个容器 docker rm -f 容器名/容器ID #删除多个容器 空格隔开要删除的容器名或容器ID docker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID #删除全部容器 docker rm -f $(docker ps -aq) 5.容器端口与服务器端口映射\n-p 宿主机端口:容器端口 #把redis1容器的6373端口映射为宿主机的8888，在外部访问8888时会指向容器的6373端口 docker run -itd --name redis1 -p 8888:6373 redis:5.0.5 /bin/bash 6.进入容器方式\ndocker exec -it 容器名/容器ID /bin/bash docker attach 容器名/容器ID 7.从容器内 退出到自己服务器中 需注意 两个退出命令的区别\n#-----直接退出 未添加 -d(持久化运行容器) 时 执行此参数 容器会被关闭  exit 12 # 优雅提出 --- 无论是否添加-d 参数 执行此命令容器都不会被关闭 Ctrl + p + q 8.停止容器\ndocker stop 容器ID/容器名 9.重启容器\ndocker restart 容器ID/容器名 10.启动容器\ndocker start 容器ID/容器名 11.kill 容器\ndocker kill 容器ID/容器名 12.容器文件拷贝 —无论容器是否开启 都可以进行拷贝\n#docker cp 容器ID/名称:文件路径 要拷贝到外部的路径 | 要拷贝到外部的路径 容器ID/名称:文件路径 #从容器内 拷出 docker cp 容器ID/名称: 容器内路径 容器外路径 #从外部 拷贝文件到容器内 docker cp 容器外路径 容器ID/名称: 容器内路径 13.查看容器日志\ndocker logs -f --tail=要查看末尾多少行 默认all 容器ID 14.设置容器开机自启动\n--restart=always docker run -itd --name redis002 -p 8888:6379 --restart=always redis:5.0.5 /bin/bash 15.容器挂载文件（在启动时需要设置好，可以挂载多个文件）\n-v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 # 运行一个docker redis 容器 进行 端口映射 两个数据卷挂载 设置开机自启动 docker run -d -p 6379:6379 --name redis505 --restart=always -v /var/lib/redis/data/:/data -v /var/lib/redis/conf/:/usr/local/etc/redis/redis.conf redis:5.0.5 --requirepass \u0026#34;password\u0026#34; 16.修改容器启动配置\ndocker update --restart=always 容器Id 或者 容器名 或 docker container update --restart=always 容器Id 或者 容器名 17.更换容器名\ndocker rename 容器ID/容器名 新容器名 18.修改容器后提交为镜像\ndocker commit -m=\u0026#34;提交信息\u0026#34; -a=\u0026#34;作者信息\u0026#34; 容器名/容器ID 提交后的镜像名:Tag 到这里docker常用命令结束了，这些足够工作中使用了。\n","permalink":"https://bobby-sheng.github.io/posts/tech/docker%E5%91%BD%E4%BB%A4/","summary":"docker主要分为镜像、容器。个人理解镜像是一个封装好的仓库，容器就是把这个仓库拿过来，里面的东西原封不动，可以随意操作而不会影响镜像内容","title":"Docker命令大全"},{"content":"","permalink":"https://bobby-sheng.github.io/posts/read/%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95%E6%9C%89%E6%96%87%E7%AB%A0%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89/","summary":"","title":"笔记目录有文章，这里没有"},{"content":"","permalink":"https://bobby-sheng.github.io/posts/life/%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95%E6%9C%89%E6%96%87%E7%AB%A0%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89/","summary":"","title":"笔记目录有文章，这里没有"},{"content":"","permalink":"https://bobby-sheng.github.io/posts/blog/%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95%E6%9C%89%E6%96%87%E7%AB%A0%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89/","summary":"","title":"笔记目录有文章，这里没有"},{"content":"1、通过以下地址获取速度较快的ip作为映射地址(需要在本地可以ping通的) https://ping.chinaz.com/github.com 2、Windows系统配置 a.打开host文件，路径一般是下面这个\nC:\\Windows\\System32\\drivers\\etc\\ b.在host文件中加找到的ip做github.com的映射\n52.192.72.89\tgithub.com c.Windows系统需要重启DNS解析配置才会生效\nipconfig /flushdns 3、Linux系统配置 a. vim /etc/hosts增加获取到的代理ip\n52.192.72.89\tgithub.com 总结：获取到可ping通的代理地址后配置到hosts系统文件中，打开网页访问域名的时候会指向你配置的那个ip。Windows和Linux系统配置差不多，Windows需要重启下DNS解析。\n","permalink":"https://bobby-sheng.github.io/posts/tech/github%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/","summary":"1、通过以下地址获取速度较快的ip作为映射地址(需要在本地可以ping通的) https://ping.chinaz.com/github.com 2、Windows系统配置 a.打开host文件，路径一般是下面","title":"Github连接超时处理"},{"content":"1、py官方库 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 2、pypc网站 https://pypi.org/project/ 3、py各大镜像库 https://pypi.tuna.tsinghua.edu.cn/simple http://mirrors.aliyun.com/pypi/simple/ http://pypi.douban.com/simple/ http://pypi.hustunique.com/ http://pypi.sdutlinux.org/ http://pypi.mirrors.ustc.edu.cn/ ","permalink":"https://bobby-sheng.github.io/posts/tech/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%9C%B0%E5%9D%80/","summary":"1、py官方库 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 2、pypc网站 https://pypi.org/project/ 3、py各大镜像库 https://pypi.tuna.tsinghua.edu.cn/simple http://mirrors.aliyun.com/pypi/simple/ http://pypi.douban.com/simple/ http://pypi.hustunique.com/ http://pypi.sdutlinux.org/ http://pypi.mirrors.ustc.edu.cn/","title":"Python离线安装包地址"},{"content":"md文件开端 #title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #date: {{ .Date }} #lastmod: {{ .Date }} #author: [\u0026#34;Sulv\u0026#34;] #categories: #- 分类1 #- 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; caption: \u0026#34;\u0026#34; alt: \u0026#34;\u0026#34; relative: false #--- hugo操作命令 hugo -F --cleanDestinationDir 清除后生成public文件，可能会出现漏上传 hugo --buildDrafts 全部生成public git init git add . git commit -m \u0026#39;create blog\u0026#39; git remote add origin https://github.com/bobby-sheng/bobby-sheng.github.io.git git push -u origin master ##如果push失败，比如time out...可尝试下面的命令 git config --global http.sslVerify \u0026#34;false\u0026#34; git config --global --unset http.proxy git config --global --unset https.proxy #(2)之后再修改、更新博客 git add . git commit -m \u0026#39;add blogs\u0026#39; git push -u origin master bobby-sheng ","permalink":"https://bobby-sheng.github.io/posts/tech/hugo%E6%90%AD%E5%BB%BA%E6%89%8B%E6%8A%84/","summary":"md文件开端 #title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #date: {{ .Date }} #lastmod: {{ .Date }} #author: [\u0026#34;Sulv\u0026#34;] #categories: #- 分类1 #- 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填","title":"Hugo搭建手抄"},{"content":"","permalink":"https://bobby-sheng.github.io/posts/tech/tag/","summary":"","title":"标签模板"},{"content":"分享工作与生活 O(∩_∩)O哈哈~ ","permalink":"https://bobby-sheng.github.io/about/","summary":"分享工作与生活 O(∩_∩)O哈哈~","title":"About"}]